// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: proto/v1/chat/chat.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ConversationService_CreateConversation_FullMethodName = "/chat.ConversationService/CreateConversation"
	ConversationService_GetConversation_FullMethodName    = "/chat.ConversationService/GetConversation"
	ConversationService_ListConversations_FullMethodName  = "/chat.ConversationService/ListConversations"
	ConversationService_AddParticipants_FullMethodName    = "/chat.ConversationService/AddParticipants"
	ConversationService_RemoveParticipants_FullMethodName = "/chat.ConversationService/RemoveParticipants"
)

// ConversationServiceClient is the client API for ConversationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConversationServiceClient interface {
	CreateConversation(ctx context.Context, in *CreateConversationRequest, opts ...grpc.CallOption) (*Conversation, error)
	GetConversation(ctx context.Context, in *GetConversationRequest, opts ...grpc.CallOption) (*Conversation, error)
	ListConversations(ctx context.Context, in *ListConversationsRequest, opts ...grpc.CallOption) (*ListConversationsResponse, error)
	AddParticipants(ctx context.Context, in *AddParticipantsRequest, opts ...grpc.CallOption) (*Conversation, error)
	RemoveParticipants(ctx context.Context, in *RemoveParticipantsRequest, opts ...grpc.CallOption) (*Conversation, error)
}

type conversationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConversationServiceClient(cc grpc.ClientConnInterface) ConversationServiceClient {
	return &conversationServiceClient{cc}
}

func (c *conversationServiceClient) CreateConversation(ctx context.Context, in *CreateConversationRequest, opts ...grpc.CallOption) (*Conversation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Conversation)
	err := c.cc.Invoke(ctx, ConversationService_CreateConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationServiceClient) GetConversation(ctx context.Context, in *GetConversationRequest, opts ...grpc.CallOption) (*Conversation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Conversation)
	err := c.cc.Invoke(ctx, ConversationService_GetConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationServiceClient) ListConversations(ctx context.Context, in *ListConversationsRequest, opts ...grpc.CallOption) (*ListConversationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListConversationsResponse)
	err := c.cc.Invoke(ctx, ConversationService_ListConversations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationServiceClient) AddParticipants(ctx context.Context, in *AddParticipantsRequest, opts ...grpc.CallOption) (*Conversation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Conversation)
	err := c.cc.Invoke(ctx, ConversationService_AddParticipants_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationServiceClient) RemoveParticipants(ctx context.Context, in *RemoveParticipantsRequest, opts ...grpc.CallOption) (*Conversation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Conversation)
	err := c.cc.Invoke(ctx, ConversationService_RemoveParticipants_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConversationServiceServer is the server API for ConversationService service.
// All implementations must embed UnimplementedConversationServiceServer
// for forward compatibility.
type ConversationServiceServer interface {
	CreateConversation(context.Context, *CreateConversationRequest) (*Conversation, error)
	GetConversation(context.Context, *GetConversationRequest) (*Conversation, error)
	ListConversations(context.Context, *ListConversationsRequest) (*ListConversationsResponse, error)
	AddParticipants(context.Context, *AddParticipantsRequest) (*Conversation, error)
	RemoveParticipants(context.Context, *RemoveParticipantsRequest) (*Conversation, error)
	mustEmbedUnimplementedConversationServiceServer()
}

// UnimplementedConversationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConversationServiceServer struct{}

func (UnimplementedConversationServiceServer) CreateConversation(context.Context, *CreateConversationRequest) (*Conversation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateConversation not implemented")
}
func (UnimplementedConversationServiceServer) GetConversation(context.Context, *GetConversationRequest) (*Conversation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConversation not implemented")
}
func (UnimplementedConversationServiceServer) ListConversations(context.Context, *ListConversationsRequest) (*ListConversationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConversations not implemented")
}
func (UnimplementedConversationServiceServer) AddParticipants(context.Context, *AddParticipantsRequest) (*Conversation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddParticipants not implemented")
}
func (UnimplementedConversationServiceServer) RemoveParticipants(context.Context, *RemoveParticipantsRequest) (*Conversation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveParticipants not implemented")
}
func (UnimplementedConversationServiceServer) mustEmbedUnimplementedConversationServiceServer() {}
func (UnimplementedConversationServiceServer) testEmbeddedByValue()                             {}

// UnsafeConversationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConversationServiceServer will
// result in compilation errors.
type UnsafeConversationServiceServer interface {
	mustEmbedUnimplementedConversationServiceServer()
}

func RegisterConversationServiceServer(s grpc.ServiceRegistrar, srv ConversationServiceServer) {
	// If the following call pancis, it indicates UnimplementedConversationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConversationService_ServiceDesc, srv)
}

func _ConversationService_CreateConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateConversationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationServiceServer).CreateConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationService_CreateConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationServiceServer).CreateConversation(ctx, req.(*CreateConversationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationService_GetConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConversationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationServiceServer).GetConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationService_GetConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationServiceServer).GetConversation(ctx, req.(*GetConversationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationService_ListConversations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConversationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationServiceServer).ListConversations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationService_ListConversations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationServiceServer).ListConversations(ctx, req.(*ListConversationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationService_AddParticipants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddParticipantsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationServiceServer).AddParticipants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationService_AddParticipants_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationServiceServer).AddParticipants(ctx, req.(*AddParticipantsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationService_RemoveParticipants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveParticipantsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationServiceServer).RemoveParticipants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationService_RemoveParticipants_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationServiceServer).RemoveParticipants(ctx, req.(*RemoveParticipantsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ConversationService_ServiceDesc is the grpc.ServiceDesc for ConversationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConversationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chat.ConversationService",
	HandlerType: (*ConversationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateConversation",
			Handler:    _ConversationService_CreateConversation_Handler,
		},
		{
			MethodName: "GetConversation",
			Handler:    _ConversationService_GetConversation_Handler,
		},
		{
			MethodName: "ListConversations",
			Handler:    _ConversationService_ListConversations_Handler,
		},
		{
			MethodName: "AddParticipants",
			Handler:    _ConversationService_AddParticipants_Handler,
		},
		{
			MethodName: "RemoveParticipants",
			Handler:    _ConversationService_RemoveParticipants_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/v1/chat/chat.proto",
}

const (
	MessageService_SendMessage_FullMethodName   = "/chat.MessageService/SendMessage"
	MessageService_ListMessages_FullMethodName  = "/chat.MessageService/ListMessages"
	MessageService_DeleteMessage_FullMethodName = "/chat.MessageService/DeleteMessage"
	MessageService_EditMessage_FullMethodName   = "/chat.MessageService/EditMessage"
)

// MessageServiceClient is the client API for MessageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MessageServiceClient interface {
	SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*Message, error)
	ListMessages(ctx context.Context, in *ListMessagesRequest, opts ...grpc.CallOption) (*ListMessagesResponse, error)
	DeleteMessage(ctx context.Context, in *DeleteMessageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	EditMessage(ctx context.Context, in *EditMessageRequest, opts ...grpc.CallOption) (*Message, error)
}

type messageServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMessageServiceClient(cc grpc.ClientConnInterface) MessageServiceClient {
	return &messageServiceClient{cc}
}

func (c *messageServiceClient) SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*Message, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Message)
	err := c.cc.Invoke(ctx, MessageService_SendMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) ListMessages(ctx context.Context, in *ListMessagesRequest, opts ...grpc.CallOption) (*ListMessagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMessagesResponse)
	err := c.cc.Invoke(ctx, MessageService_ListMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) DeleteMessage(ctx context.Context, in *DeleteMessageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, MessageService_DeleteMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) EditMessage(ctx context.Context, in *EditMessageRequest, opts ...grpc.CallOption) (*Message, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Message)
	err := c.cc.Invoke(ctx, MessageService_EditMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MessageServiceServer is the server API for MessageService service.
// All implementations must embed UnimplementedMessageServiceServer
// for forward compatibility.
type MessageServiceServer interface {
	SendMessage(context.Context, *SendMessageRequest) (*Message, error)
	ListMessages(context.Context, *ListMessagesRequest) (*ListMessagesResponse, error)
	DeleteMessage(context.Context, *DeleteMessageRequest) (*emptypb.Empty, error)
	EditMessage(context.Context, *EditMessageRequest) (*Message, error)
	mustEmbedUnimplementedMessageServiceServer()
}

// UnimplementedMessageServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMessageServiceServer struct{}

func (UnimplementedMessageServiceServer) SendMessage(context.Context, *SendMessageRequest) (*Message, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMessage not implemented")
}
func (UnimplementedMessageServiceServer) ListMessages(context.Context, *ListMessagesRequest) (*ListMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMessages not implemented")
}
func (UnimplementedMessageServiceServer) DeleteMessage(context.Context, *DeleteMessageRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMessage not implemented")
}
func (UnimplementedMessageServiceServer) EditMessage(context.Context, *EditMessageRequest) (*Message, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditMessage not implemented")
}
func (UnimplementedMessageServiceServer) mustEmbedUnimplementedMessageServiceServer() {}
func (UnimplementedMessageServiceServer) testEmbeddedByValue()                        {}

// UnsafeMessageServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MessageServiceServer will
// result in compilation errors.
type UnsafeMessageServiceServer interface {
	mustEmbedUnimplementedMessageServiceServer()
}

func RegisterMessageServiceServer(s grpc.ServiceRegistrar, srv MessageServiceServer) {
	// If the following call pancis, it indicates UnimplementedMessageServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MessageService_ServiceDesc, srv)
}

func _MessageService_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_SendMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).SendMessage(ctx, req.(*SendMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_ListMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).ListMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_ListMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).ListMessages(ctx, req.(*ListMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_DeleteMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).DeleteMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_DeleteMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).DeleteMessage(ctx, req.(*DeleteMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_EditMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EditMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).EditMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_EditMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).EditMessage(ctx, req.(*EditMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MessageService_ServiceDesc is the grpc.ServiceDesc for MessageService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MessageService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chat.MessageService",
	HandlerType: (*MessageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendMessage",
			Handler:    _MessageService_SendMessage_Handler,
		},
		{
			MethodName: "ListMessages",
			Handler:    _MessageService_ListMessages_Handler,
		},
		{
			MethodName: "DeleteMessage",
			Handler:    _MessageService_DeleteMessage_Handler,
		},
		{
			MethodName: "EditMessage",
			Handler:    _MessageService_EditMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/v1/chat/chat.proto",
}

const (
	MessageStatusService_MarkAsRead_FullMethodName       = "/chat.MessageStatusService/MarkAsRead"
	MessageStatusService_GetMessageStatus_FullMethodName = "/chat.MessageStatusService/GetMessageStatus"
)

// MessageStatusServiceClient is the client API for MessageStatusService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MessageStatusServiceClient interface {
	MarkAsRead(ctx context.Context, in *MarkAsReadRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetMessageStatus(ctx context.Context, in *GetMessageStatusRequest, opts ...grpc.CallOption) (*MessageStatusResponse, error)
}

type messageStatusServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMessageStatusServiceClient(cc grpc.ClientConnInterface) MessageStatusServiceClient {
	return &messageStatusServiceClient{cc}
}

func (c *messageStatusServiceClient) MarkAsRead(ctx context.Context, in *MarkAsReadRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, MessageStatusService_MarkAsRead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageStatusServiceClient) GetMessageStatus(ctx context.Context, in *GetMessageStatusRequest, opts ...grpc.CallOption) (*MessageStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageStatusResponse)
	err := c.cc.Invoke(ctx, MessageStatusService_GetMessageStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MessageStatusServiceServer is the server API for MessageStatusService service.
// All implementations must embed UnimplementedMessageStatusServiceServer
// for forward compatibility.
type MessageStatusServiceServer interface {
	MarkAsRead(context.Context, *MarkAsReadRequest) (*emptypb.Empty, error)
	GetMessageStatus(context.Context, *GetMessageStatusRequest) (*MessageStatusResponse, error)
	mustEmbedUnimplementedMessageStatusServiceServer()
}

// UnimplementedMessageStatusServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMessageStatusServiceServer struct{}

func (UnimplementedMessageStatusServiceServer) MarkAsRead(context.Context, *MarkAsReadRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkAsRead not implemented")
}
func (UnimplementedMessageStatusServiceServer) GetMessageStatus(context.Context, *GetMessageStatusRequest) (*MessageStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMessageStatus not implemented")
}
func (UnimplementedMessageStatusServiceServer) mustEmbedUnimplementedMessageStatusServiceServer() {}
func (UnimplementedMessageStatusServiceServer) testEmbeddedByValue()                              {}

// UnsafeMessageStatusServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MessageStatusServiceServer will
// result in compilation errors.
type UnsafeMessageStatusServiceServer interface {
	mustEmbedUnimplementedMessageStatusServiceServer()
}

func RegisterMessageStatusServiceServer(s grpc.ServiceRegistrar, srv MessageStatusServiceServer) {
	// If the following call pancis, it indicates UnimplementedMessageStatusServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MessageStatusService_ServiceDesc, srv)
}

func _MessageStatusService_MarkAsRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkAsReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageStatusServiceServer).MarkAsRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageStatusService_MarkAsRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageStatusServiceServer).MarkAsRead(ctx, req.(*MarkAsReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageStatusService_GetMessageStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMessageStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageStatusServiceServer).GetMessageStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageStatusService_GetMessageStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageStatusServiceServer).GetMessageStatus(ctx, req.(*GetMessageStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MessageStatusService_ServiceDesc is the grpc.ServiceDesc for MessageStatusService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MessageStatusService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chat.MessageStatusService",
	HandlerType: (*MessageStatusServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MarkAsRead",
			Handler:    _MessageStatusService_MarkAsRead_Handler,
		},
		{
			MethodName: "GetMessageStatus",
			Handler:    _MessageStatusService_GetMessageStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/v1/chat/chat.proto",
}

const (
	RealtimeService_MessageStream_FullMethodName = "/chat.RealtimeService/MessageStream"
)

// RealtimeServiceClient is the client API for RealtimeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RealtimeServiceClient interface {
	MessageStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[RealtimeMessageRequest, RealtimeMessageResponse], error)
}

type realtimeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRealtimeServiceClient(cc grpc.ClientConnInterface) RealtimeServiceClient {
	return &realtimeServiceClient{cc}
}

func (c *realtimeServiceClient) MessageStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[RealtimeMessageRequest, RealtimeMessageResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RealtimeService_ServiceDesc.Streams[0], RealtimeService_MessageStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RealtimeMessageRequest, RealtimeMessageResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RealtimeService_MessageStreamClient = grpc.BidiStreamingClient[RealtimeMessageRequest, RealtimeMessageResponse]

// RealtimeServiceServer is the server API for RealtimeService service.
// All implementations must embed UnimplementedRealtimeServiceServer
// for forward compatibility.
type RealtimeServiceServer interface {
	MessageStream(grpc.BidiStreamingServer[RealtimeMessageRequest, RealtimeMessageResponse]) error
	mustEmbedUnimplementedRealtimeServiceServer()
}

// UnimplementedRealtimeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRealtimeServiceServer struct{}

func (UnimplementedRealtimeServiceServer) MessageStream(grpc.BidiStreamingServer[RealtimeMessageRequest, RealtimeMessageResponse]) error {
	return status.Errorf(codes.Unimplemented, "method MessageStream not implemented")
}
func (UnimplementedRealtimeServiceServer) mustEmbedUnimplementedRealtimeServiceServer() {}
func (UnimplementedRealtimeServiceServer) testEmbeddedByValue()                         {}

// UnsafeRealtimeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RealtimeServiceServer will
// result in compilation errors.
type UnsafeRealtimeServiceServer interface {
	mustEmbedUnimplementedRealtimeServiceServer()
}

func RegisterRealtimeServiceServer(s grpc.ServiceRegistrar, srv RealtimeServiceServer) {
	// If the following call pancis, it indicates UnimplementedRealtimeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RealtimeService_ServiceDesc, srv)
}

func _RealtimeService_MessageStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RealtimeServiceServer).MessageStream(&grpc.GenericServerStream[RealtimeMessageRequest, RealtimeMessageResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RealtimeService_MessageStreamServer = grpc.BidiStreamingServer[RealtimeMessageRequest, RealtimeMessageResponse]

// RealtimeService_ServiceDesc is the grpc.ServiceDesc for RealtimeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RealtimeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chat.RealtimeService",
	HandlerType: (*RealtimeServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "MessageStream",
			Handler:       _RealtimeService_MessageStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "proto/v1/chat/chat.proto",
}

const (
	InternalUserService_SyncUser_FullMethodName = "/chat.InternalUserService/SyncUser"
)

// InternalUserServiceClient is the client API for InternalUserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InternalUserServiceClient interface {
	SyncUser(ctx context.Context, in *SyncUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type internalUserServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInternalUserServiceClient(cc grpc.ClientConnInterface) InternalUserServiceClient {
	return &internalUserServiceClient{cc}
}

func (c *internalUserServiceClient) SyncUser(ctx context.Context, in *SyncUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, InternalUserService_SyncUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InternalUserServiceServer is the server API for InternalUserService service.
// All implementations must embed UnimplementedInternalUserServiceServer
// for forward compatibility.
type InternalUserServiceServer interface {
	SyncUser(context.Context, *SyncUserRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedInternalUserServiceServer()
}

// UnimplementedInternalUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedInternalUserServiceServer struct{}

func (UnimplementedInternalUserServiceServer) SyncUser(context.Context, *SyncUserRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncUser not implemented")
}
func (UnimplementedInternalUserServiceServer) mustEmbedUnimplementedInternalUserServiceServer() {}
func (UnimplementedInternalUserServiceServer) testEmbeddedByValue()                             {}

// UnsafeInternalUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InternalUserServiceServer will
// result in compilation errors.
type UnsafeInternalUserServiceServer interface {
	mustEmbedUnimplementedInternalUserServiceServer()
}

func RegisterInternalUserServiceServer(s grpc.ServiceRegistrar, srv InternalUserServiceServer) {
	// If the following call pancis, it indicates UnimplementedInternalUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&InternalUserService_ServiceDesc, srv)
}

func _InternalUserService_SyncUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalUserServiceServer).SyncUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InternalUserService_SyncUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalUserServiceServer).SyncUser(ctx, req.(*SyncUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InternalUserService_ServiceDesc is the grpc.ServiceDesc for InternalUserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InternalUserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chat.InternalUserService",
	HandlerType: (*InternalUserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SyncUser",
			Handler:    _InternalUserService_SyncUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/v1/chat/chat.proto",
}
